  #' Query Layer
  #'
  #' Query a layer on an arcgis server
  #'
  #' @param endpoint a string defining the enpoint url.
  #' It can be generated by the \code{feature_server_endpoint} and \code{map_server_endpoint} functons.
  #' See https://developers.arcgis.com/rest/services-reference/get-started-with-the-services-directory.htm
  #' @param my_token an access token acquired via \code{get_token}
  #' @param in_geometry the geometry to use when applying a spatial filter to the layer. This should be an sf object (bounding boxes are accepted and are the fastest).
  #' @param spatial_filter The type of spatial filter. Defaults to intersection (intersects).
  #' Options are: intersects, contains, crosses, envelope_intersects, index_intersects, overlaps, touches, within
  #'
  #' @param query a named vector of parameters to include in the query
  #' @param bounding_box DEPRECTED. An optional bounding box (generated by sf::st_bbox()) to perform a spatial intersects
  #' @param crs the output crs, defaulting to 4326
  #' @param return_geometry should the geometry be returned or just a table?
  #'
  #' @return an sf object
  #' @export query_layer
  #'
  #' @import httr
  #' @importFrom sf st_transform
  #' @importFrom magrittr %>%
  #' @import tibble
  #' @importFrom lifecycle deprecated
  #' @importFrom lifecycle is_present
  #' @importFrom progress progress_bar
  #' @importFrom purrr map
  #' @importFrom dplyr bind_rows
query_layer <-
  function(endpoint,
           in_geometry = NULL,
           spatial_filter = "intersects",
           return_geometry = TRUE,
           query = NULL,
           crs = 4326,
           my_token = NULL,
           bounding_box = lifecycle::deprecated()
           ) {
    # Check depreciated arguments ----------
    # Check if user has supplied `baz` instead of `bar`
    if (lifecycle::is_present(bounding_box)) {
      # Signal the deprecation to the user
      deprecate_warn("0.0.0.9500", "query_layer(bounding_box = )", "query_layer(geometry = )")
      # Deal with the deprecated argument for compatibility
      in_geometry <- bounding_box
    }

    # Check that a valid token has been passed in
    stopifnot(is.null(my_token) || c("Token") %in% class(my_token))

    #https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm


    # It would be useful to add a line of code in here to check and auto refresh the token
    # Get the details of the layer to
    layer_details <- get_layer_details(endpoint = endpoint, my_token = my_token)

    # If an in_geometry has been specified then generate the spatial query and combine with the query parameters
    if (!is.null(in_geometry)) {
      query <- modify_named_vector(query, spatial_query(x = in_geometry,
                                                        spatial_filter = esri_spatial_filter(spatial_filter)))
    }

    argument_parameters <- c(returnGeometry = lower_logical(return_geometry))

    # Add query parameters which have been set as arguments in the function
    query <- modify_named_vector(query, argument_parameters)
    # Add in the default parameters but only where they are not present in query
    query <- modify_named_vector(default_query_parameters(), query)

    # Previously I was requesting all the feature IDs for a layer, counting them and then
    # checking if there were none matching the query.This added a lot of time when there were
    # many feature IDs to return
    count <- get_count(endpoint = endpoint, query = query, my_token = my_token)

    if(count < 1){
      warning("No data matching query, returning an empty tibble")
      return(tibble::tibble())
    }


    # Add the token into the query
    query <- modify_named_vector(query, c(token = parse_access_token(my_token)))
    # Generate the query string
    # query_string <- query_string(query = query, my_token = my_token)

    query_url <- paste0(endpoint, "/query")
    # This behaviour is undesirable when queries become more complex.
    # Need to find a way of making the query string available to users
    #message(paste0("Requesting data..."))

    # This ultimately needs moving into its own function
    # Get by FIDs
    # If the returned count exceeds the max record count, then the get data function should be
    # mapped.

    # First get the FIDs use in querying the endpoint
    object_ids <-
      get_feature_ids(endpoint = endpoint,
                      query = query,
                      my_token = my_token)
    # Then split the vector so it doesn't exceed the max record count
    object_ids_split <-
      split_vector(x = object_ids$objectIds, max_length = layer_details$maxRecordCount)

    querys <-
      purrr::map(object_ids_split,
                 ~ modify_named_vector(query, where_in_query(object_ids$objectIdFieldName, .x)))

    # Define a progress bar
    pb <- progress::progress_bar$new(total = length(querys),
                                     clear = FALSE,
                                     width = 60,
                                     format = "  Downloading data [:bar] :percent in :elapsed eta: :eta")

    # Download the data for each query
    data_list <- purrr::map(querys,
                            ~ get_data(
                              query_url = query_url,
                              query = .x,
                              return_geometry = return_geometry,
                              pb = pb
                            ))

    data <- dplyr::bind_rows(data_list)

    # Parse the variables -----
    # This should probably be wrapped up into one parsing function at some point
    data <-
      parse_coded_domains(data,
                          domain_lookup(layer_details))

    data <- parse_datetimes(data = data,
                            feature_details = layer_details)

    # If the specified crs is not 4326 (the current crs) then transform the data
    # This might be redundant as we can specify the outcrs when requesting the data
    if (crs != 4326 & return_geometry) {
      data <- data %>% sf::st_transform(crs = crs)
    }

    # It would be possible to expand the code here to actually request all features in a layer
    # exceeding the maximum limit. This can be done by knowing the maxRecordCount and the count of
    # features then running a series of where objectid less than & objectid more than queries
    # to retrieve all the data. Could even add in a progress bar
    # Warn if the number of rows in the data is
    # if(nrow(data) == layer_details$maxRecordCount){
    #   warning("May have reached maxRecordCount.")
    # }
    if(nrow(data) == 0){
      warning("No data returned by query.")
    }
    return(data)
  }

