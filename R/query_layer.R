  #' Query Layer
  #'
  #' Query a layer on an arcgis server
  #'
  #' @param endpoint a string defining the enpoint url.
  #' It can be generated by the \code{feature_server_endpoint} and \code{map_server_endpoint} functons.
  #' See https://developers.arcgis.com/rest/services-reference/get-started-with-the-services-directory.htm
  #' @param my_token an access token acquired via \code{get_token}
  #' @param query a named vector of parameters to include in the query
  #' @param bounding_box an optional bounding box (generated by sf::st_bbox()) to perform a spatial intersects
  #' @param crs the output crs, defaulting to 4326
  #'
  #' @return an sf object
  #' @export query_layer
  #'
  #' @import httr
  #' @importFrom sf st_transform
  #' @importFrom magrittr %>%
  #' @import tibble
query_layer <-
  function(endpoint,
           query = NULL,
           bounding_box = NULL,
           crs = 4326,
           my_token = NULL) {
    #https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm


    # Get the details of the layer to
    layer_details <- get_layer_details(endpoint = endpoint, my_token = my_token)

    # If a bounding box has been specified then generate the spatial query and combine with the query parameters
    if (!is.null(bounding_box)) {
      query <- c(query, spatial_query_to_list(bbox = bounding_box))
    }

    # Define a named vecotr of default query parameters for returning spatial data
    default_parameters <- default_query_parameters()

    default_parameters <-
      default_parameters[!(names(default_parameters) %in% names(query))]
    query <- c(default_parameters, query)

    feature_ids <- get_feature_ids(endpoint = endpoint, query = query, my_token = my_token)

    if(length(feature_ids$objectIds) < 1){
      warning("No data matching query, returning an empty tibble")
      return(tibble::tibble())
    }

    # Generate the query string
    query_string <- query_string(query = query, my_token = my_token)

    query_url <- paste0(endpoint, "/query", query_string)
    message(paste0("Requesting data:\n", query_url))


    data <- get_geojson(query_url)

    # Parse the variables -----
    # This should probably be wrapped up into one parsing function at some point
    data <-
      parse_coded_domains(data,
                          domain_lookup(layer_details))

    data <- parse_datetimes(data = data,
                            feature_details = layer_details)

    # If the specified crs is not 4326 (the current crs) then transform the data
    # This might be redundant as we can specify the outcrs when requesting the data
    if (crs != 4326) {
      data <- data %>% sf::st_transform(crs = crs)
    }

    # Warn if the number of rows in the data is
    if(nrow(data) == layer_details$maxRecordCount){
      warning("May have reached limit of maximum features to return, try performing query to narrow down results.")
    }

    return(data)
  }
