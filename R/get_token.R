#' Get Access Token
#'
#' Get an access token for accessing a service
#'
#' @param use_cache should the token be cached? Currently not working
#' @param auto_refresh should the token automatically be refreshed if it has expired?
#' @param client_id app credential: client ID
#' @param client_secret app credential: client secret
#' @param app_name app credential: app name
#' @param redirect_uri te url to redirect to after authenticating. default is httr::oauth_callback(). This needs to be added into your web app on arc gis for developers.
#' @export get_token
#' @import httr
#' @importFrom purrr map_lgl
get_token <-
  function(client_id = NULL, client_secret = NULL, app_name = NULL,
           use_cache = TRUE, auto_refresh = TRUE,
           redirect_uri = httr::oauth_callback()
           ) {

    credentials <- list(client_id = client_id,
                        client_secret = client_secret,
                        app_name = app_name)

    if(any(purrr::map_lgl(credentials, is.null))){
      # message("Getting credentials from environment variables")
      credentials <- get_credentials()
    }
    endpoint <-
      httr::oauth_endpoint(access = "https://www.arcgis.com/sharing/rest/oauth2/token/",
                     authorize  = "https://www.arcgis.com/sharing/rest/oauth2/authorize/")
    app <-
      httr::oauth_app(appname = credentials$app_name,
                key = credentials$client_id,
                secret = credentials$client_secret,
                # When other people try to run get token they get an eror saying
                # incorrect redirect_uri. I wonder if this is because different users
                # have a different default uri. It is possible to reproduce the error by setting
                # the redirect uri below to one that doesn't match the app set up in arc
                # Doesn't work on RStudio Server
                redirect_uri = redirect_uri)

    # With the request send the datetime which is then automatically stored with the token
    # This is then checked against the expiry seconds and the token is refreshed if neccessary
    my_token <-
      httr::oauth2.0_token(endpoint = endpoint, app = app, cache = use_cache,
                           query_authorize_extra = list(grant_datetime = Sys.time()))

    # httr doesn't parse the credentials correctly into a list
    my_token$credentials <- jsonlite::fromJSON(my_token$credentials)

    # Check expiry and refresh if neccessary
    # The refresh token is an alteration to httr:::refresh_oauth2.0
    if(auto_refresh & token_expired(my_token)){
      my_token$credentials <-
        refresh_token(
          endpoint = endpoint,
          app = app,
          credentials = my_token$credentials,
          user_params = NULL
        )
      my_token$params$query_authorize_extra$grant_datetime <-
        Sys.time()
    }

    return(my_token)
  }
#' Token Expired
#'
#' Has the Oauth token expired
#'
#' @param my_token an access token generated by get_token
#' @return logical value detailing whether the token has or has not expired
#' @importFrom lubridate ymd_hms
#' @importFrom lubridate seconds
#' @importFrom jsonlite fromJSON
token_expired <-
  function(my_token){
    # Extract the grant time which is passed in when making the request
    grant_dttm <- my_token$params$query_authorize_extra$grant_datetime
    # and the expiry time which is in seconds
    expiry_seconds <- my_token$credentials$expires_in
    # calculate when the token expires and check whether this has occured yet
    expires_at <- lubridate::ymd_hms(grant_dttm) + lubridate::seconds(expiry_seconds)
    # There is something weird going on with timezones so I added the call to
    # ymd_hms, there is probably a better way of doing this to assert that the timezones are equal
    expired <- lubridate::ymd_hms(Sys.time()) > expires_at
    return(expired)
  }
#' Get/Set Credentials
#'
#' Get or set app credentials
#'
#' set_credentials and get_credentials set and retrieve environment variables for the client id, client secret and app name.
#' This then allows get_token to retrieve the variables.
#' @param client_id The client ID. Taken from you app dashboard on arcgis for developers
#' @param client_secret The client secret. Taken from you app dashboard on arcgis for developers
#' @param app_name The name of your app. Taken from you app dashboard on arcgis for developers
#' @export set_credentials
#' @importFrom keyring key_set
#' @importFrom keyring key_get
set_credentials <-
  function(client_id,
           client_secret,
           app_name){
    keyring::key_set_with_value(service = "getarc", username = "client_id", password = client_id)
    keyring::key_set_with_value(service = "getarc", username = "client_secret", password = client_secret)
    keyring::key_set_with_value(service = "getarc", username = "app_name", password = app_name)
  }
get_credentials <-
  function(){
    credentials <-
      list(
        client_id = keyring::key_get(service = "getarc", username = "client_id"),
        client_secret = keyring::key_get(service = "getarc", username = "client_secret"),
        app_name = keyring::key_get(service = "getarc", username = "app_name")
      )
    # Check all have been set
    valid <- purrr::map_lgl(credentials, ~.x != "")
    if(!all(valid)){
      stop(paste0(
        "Credentials not set: ", paste0(paste0("'", names(credentials)[!valid], "'"), collapse = ", "), "\n",
        "Use getarc::set_credentials() to set app credentials as environment variables."
      ))
    }
    return(credentials)
  }
